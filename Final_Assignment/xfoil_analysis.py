from parapy.geom import *
from parapy.core import *
from parapy.lib.xfoil import *
import numpy as np
import matplotlib.pyplot as plt
from kbeutils.geom.curve import airfoil_points_in_xy_plane

#This class is largely taken from the example in Tutorial 8 of KBE.
#To get rid of the CP plots when running Xfoil, follow the steps as described in XFOIL_PLOT.txt

class XfoilAnalysis(GeomBase):
    lifting_surface = Input()
    cutting_plane_span_fraction = Input()
    flydir = Input()  # False if the section to be analyzed is normal to the LE
    reynolds_number = Input()
    alpha = Input((-5, 30, 1))  # (alpha_start, alpha_end, step)
    root_section = Input()
    tip_section = Input()
    mach = Input()
    @Attribute
    # the function airfoil_points_in_xy_plane expects a section curve oriented as follow: TE-->top-->LE-->belly-->TE,
    # thus with their normal directed inboard.
    # Lifting surface curves generated starting from .dat files or using Naca4AirfoilCurve and Naca5AirfoilCurve  /
    # automatically respect this direction; but curves from intersection not (always). Thereby this check is necessary.
    #
    # Due to a bug in parapy it is not possible to reverse an edge directly, but it is possible to reverse its  /
    # bspline representation
    def section_for_analysis(self):
        return self.section.edges[0].bspline.reversed if self.section.edges[0].bspline.plane_normal[1] >= 0 \
            else self.section.edges[0].bspline

    @Attribute
    # X foil requires airfoils to be defined in the xy plane. This function (from kbeutils) takes a generic curve /
    # in space and tranforms it accordingly.
    # The transformed section has its chord aligned with the x axis and it is normalized (chord length =1)
    def section_points_xfoil(self):
        return airfoil_points_in_xy_plane(self.section_for_analysis)

    @Attribute
    def xfoil_analysis(self):  # refer to Xfoil manual for proper use!
        return run_xfoil(self.section_points_xfoil,  # run Xfoil analysis
                         self.reynolds_number,  # this should depend on chord length
                         self.alpha, # start AoA, end AoA, step
                         self.mach, #Mach number
                         norm=True,  # normalize airfoil if necessary
                         pane=True,  # smooth out the airfoil
                         cleanup=True)  # remove files generated by xfoil


    @Attribute
    def clmax(self):  # use matplotlib to generate plot
        columns = self.xfoil_analysis
        rows = tuple(zip(*columns))  # transpose array generated by xfoil
        cl = rows[1] #rows[0] is the angle of attack, rows[2] is the cl
        return max(cl) #takes the maximum of the cl-curve

    # ------------------------ wing sections for Xfoil analysis  ------------------------
    @Part  # cutting plane is positioned at % span and oriented either in flight directory or normal to LE line
    def wing_cutting_plane(self):
        return Plane \
            (reference=self.root_section.location.  # point at span percentage
             interpolate(self.tip_section.location, self.cutting_plane_span_fraction),
             normal=
             self.lifting_surface.position.Vy_ if self.flydir
             else
             (self.root_section.location - self.tip_section.location))  #


    @Part
    def section(self):
        return IntersectedShapes(shape_in=self.lifting_surface,
                                 tool=self.wing_cutting_plane)

