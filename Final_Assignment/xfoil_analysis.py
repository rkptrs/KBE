from parapy.geom import *
from parapy.core import *
from parapy.lib.xfoil import *
import numpy as np
import matplotlib.pyplot as plt
from kbeutils.geom.curve import airfoil_points_in_xy_plane


class XfoilAnalysis(GeomBase):
    lifting_surface = Input()
    cutting_plane_span_fraction = Input()
    flydir = Input()  # False if the section to be analyzed is normal to the LE
    reynolds_number = Input()
    alpha = Input((-5, 30, 1))  # (alpha_start, alpha_end, step)
    root_section = Input()
    tip_section = Input()
    mach = Input()
    @Attribute
    # the function airfoil_points_in_xy_plane expects a section curve oriented as follow: TE-->top-->LE-->belly-->TE,
    # thus with their normal directed inboard.
    # Lifting surface curves generated starting from .dat files or using Naca4AirfoilCurve and Naca5AirfoilCurve  /
    # automatically respect this direction; but curves from intersection not (always). Thereby this check is necessary.
    #
    # Due to a bug in parapy it is not possible to reverse an edge directly, but it is possible to reverse its  /
    # bspline representation
    def section_for_analysis(self):
        return self.section.edges[0].bspline.reversed if self.section.edges[0].bspline.plane_normal[1] >= 0 \
            else self.section.edges[0].bspline

    @Attribute
    # X foil requires airfoils to be defined in the xy plane. This function (from kbeutils) takes a generic curve /
    # in space and tranforms it accordingly.
    # The transformed section has its chord aligned with the x axis and it is normalized (chord length =1)
    def section_points_xfoil(self):
        return airfoil_points_in_xy_plane(self.section_for_analysis)

    @Attribute
    def xfoil_analysis(self):  # refer to Xfoil manual for proper use!
        return run_xfoil(self.section_points_xfoil,  # run Xfoil analysis
                         self.reynolds_number,  # this should depend on chord length
                         self.alpha,
                         self.mach,# start AoA, end AoA, step
                         norm=True,  # normalize airfoil if necessary
                         pane=True,  # smooth out the airfoil
                         cleanup=True)  # remove files generated by xfoil


    @Attribute
    def clmax(self):  # use matplotlib to generate plot
        columns = self.xfoil_analysis
        rows = tuple(zip(*columns))  # transpose array generated by xfoil
        cl = rows[1]
        # clmax = np.zeros(len(cl))
        # j = 0
        # for i in range(len(cl)-1):
        #     i = i+1
        #     if cl[i] < cl[i-1]:
        #         clmax[j] = cl[i-1]
        #         j = j+1
        #
        #     if j == 0:


        return max(cl)

    # ------------------------ wing sections for Xfoil analysis  ------------------------
    @Part  # cutting plane is positioned at % span and oriented either in flight directory or normal to LE line
    def wing_cutting_plane(self):
        return Plane \
            (reference=self.root_section.location.  # point at span percentage
             interpolate(self.tip_section.location, self.cutting_plane_span_fraction),
             normal=
             self.lifting_surface.position.Vy_ if self.flydir
             else
             (self.root_section.location - self.tip_section.location))  #
        # leading edge vector

    @Part
    def section(self):
        return IntersectedShapes(shape_in=self.lifting_surface,
                                 tool=self.wing_cutting_plane)

